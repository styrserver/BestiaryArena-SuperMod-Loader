## 1. In `defaultConfig` (line ~20):

**Find:**
```javascript
const defaultConfig = {
  runs: 20,
  speedupFactor: 1000,
  hideGameBoard: true,
  enableTurboAutomatically: true,
  stopOnSPlus: false,
  stopAfterTicks: 0, // 0 means no limit
  currentLocale: document.documentElement.lang === 'pt' || 
    document.querySelector('html[lang="pt"]') || 
    window.location.href.includes('/pt/') ? 'pt' : 'en'
};
```

**Change to:**
```javascript
const defaultConfig = {
  runs: 20,
  speedupFactor: 1000,
  hideGameBoard: true,
  enableTurboAutomatically: true,
  stopOnSPlus: false,
  stopAfterTicks: 0, // 0 means no limit
  stopWhenTicksReached: 0, // Stop when finding a run with this number of ticks or less
  currentLocale: document.documentElement.lang === 'pt' || 
    document.querySelector('html[lang="pt"]') || 
    window.location.href.includes('/pt/') ? 'pt' : 'en'
};
```

## 2. In translations, add the new labels:

**In the `en:` section after `stopAfterTicksLabel`:**
```javascript
stopWhenTicksReachedLabel: 'Stop when reaching ticks (0 to disable):',
copyTargetTicksReplayButton: 'Replay Target',
```

**In the `pt:` section after `stopAfterTicksLabel`:**
```javascript
stopWhenTicksReachedLabel: 'Parar ao atingir ticks (0 para desabilitar):',
copyTargetTicksReplayButton: 'Replay Alvo',
```

## 3. Complete `analyzeBoard` function (replace the entire function):

```javascript
async function analyzeBoard(runs = config.runs, statusCallback = null) {
  // Reset force stop flag
  forceStop = false;
  
  // Reset tracking variables
  currentSeed = null;
  currentRegionId = null;
  currentRoomId = null;
  currentRoomName = null;
  boardSetup = [];
  
  // Variables to store best runs
  let bestTimeRun = null;
  let bestScoreRun = null;
  let targetTicksRun = null; // To store the run that reached the target ticks
  
  // Timing variables
  const startTime = performance.now();
  const runTimes = [];
  let lastRunStart = 0;
  
  // Ensure sandbox mode
  const modeSwitched = ensureSandboxMode();
  
  // Hide the game board if configured
  const gameFrame = document.querySelector('main .frame-4');
  if (config.hideGameBoard && gameFrame) {
    gameFrame.style.display = 'none';
  }

  const results = [];
  let minTicks = Infinity;
  let minTicksResult = null;
  let maxRankPoints = 0;
  let maxRankPointsResult = null;
  let sPlusCount = 0;
  let totalRuns = 0;
  let completedRuns = 0;

  try {
    // If we just switched to sandbox mode, ensure UI is updated
    if (modeSwitched) {
      await sleep(100);
    }
    
    // Enable turbo mode if configured - do this before starting games
    if (config.enableTurboAutomatically) {
      enableTurbo(config.speedupFactor);
    }

    // Capture current map information
    try {
      const boardContext = globalThis.state.board.getSnapshot().context;
      const selectedMap = boardContext.selectedMap || {};
      
      if (selectedMap.selectedRegion && selectedMap.selectedRegion.id) {
        currentRegionId = selectedMap.selectedRegion.id;
        console.log('Captured region ID:', currentRegionId);
      }
      
      if (selectedMap.selectedRoom) {
        currentRoomId = selectedMap.selectedRoom.id;
        currentRoomName = mapIdsToNames.get(currentRoomId) || 
                           globalThis.state.utils.ROOM_NAME[currentRoomId] || 
                           selectedMap.selectedRoom.file.name;
        console.log('Captured room ID:', currentRoomId, 'Name:', currentRoomName);
      }
    } catch (error) {
      console.error('Error capturing map information:', error);
    }
    
    for (let i = 1; i <= runs; i++) {
      // Start timing this run
      lastRunStart = performance.now();
      
      // Check if forced stop was requested
      if (forceStop) {
        console.log('Analysis stopped by user');
        break;
      }
      
      // Update status callback if provided
      if (statusCallback && runTimes.length > 0) {
        // Calculate average run time and estimated time remaining
        const avgRunTime = runTimes.reduce((sum, time) => sum + time, 0) / runTimes.length;
        const remainingRuns = runs - i + 1;
        const estimatedTimeRemaining = avgRunTime * remainingRuns;
        
        statusCallback({
          current: i,
          total: runs,
          status: 'running',
          avgRunTime: avgRunTime.toFixed(0),
          estimatedTimeRemaining: formatMilliseconds(estimatedTimeRemaining)
        });
      } else if (statusCallback) {
        statusCallback({
          current: i,
          total: runs,
          status: 'running'
        });
      }
      
      // Generate a new unique seed for this run
      const runSeed = Math.floor((Date.now() * Math.random()) % 2147483647);
      console.log(`Run ${i} using generated seed: ${runSeed}`);
      
      try {
        // Start the game using direct state manipulation with embedded seed
        globalThis.state.board.send({
          type: "setState",
          fn: prevState => ({
            ...prevState,
            sandboxSeed: runSeed,
            gameStarted: true
          })
        });
        
        // Wait for game to complete
        const result = await getLastTick();
        
        // Add seed to result
        result.seed = runSeed;
        results.push(result);
        
        const { ticks, grade, rankPoints, completed } = result;
        totalRuns++;
        
        if (completed) {
          completedRuns++;
          
          // Update min ticks if this is a completed run with lower ticks
          if (ticks < minTicks) {
            minTicks = ticks;
            minTicksResult = {
              ticks,
              grade,
              rankPoints,
              seed: runSeed,
              runIndex: i
            };
            
            // Store the board configuration for best time replay
            let boardData;

            if (typeof window.$serializeBoard === 'function') {
              boardData = JSON.parse(window.$serializeBoard());
              console.log('Best time: Using window.$serializeBoard directly');
            } else if (window.BestiaryModAPI && window.BestiaryModAPI.utility && window.BestiaryModAPI.utility.serializeBoard) {
              boardData = JSON.parse(window.BestiaryModAPI.utility.serializeBoard());
              console.log('Best time: Using BestiaryModAPI.utility.serializeBoard');
            } else {
              boardData = serializeBoard();
              console.log('Best time: Using local serializeBoard implementation');
            }

            // Create a deep copy to avoid reference issues
            const boardDataCopy = structuredClone(boardData);
            boardDataCopy.seed = runSeed;

            bestTimeRun = {
              seed: runSeed,
              board: boardDataCopy
            };
            
            console.log(`New best time: ${ticks} ticks with seed ${runSeed} in run ${i}`);
          }
        }
        
        if (grade === 'S+') {
          sPlusCount++;
          // If stopOnSPlus is enabled, we might want to exit early
          if (config.stopOnSPlus) {
            console.log('Achieved S+ grade, stopping analysis early');
            break;
          }
        }
        
        // Check if should stop for reaching the desired number of ticks
        if (config.stopWhenTicksReached > 0 && completed && ticks <= config.stopWhenTicksReached) {
          console.log(`Reached target ticks: ${ticks} <= ${config.stopWhenTicksReached}, stopping analysis`);
          
          // Capture the configuration for the target replay
          let boardData;
          
          if (typeof window.$serializeBoard === 'function') {
            boardData = JSON.parse(window.$serializeBoard());
            console.log('Target ticks: Using window.$serializeBoard directly');
          } else if (window.BestiaryModAPI && window.BestiaryModAPI.utility && window.BestiaryModAPI.utility.serializeBoard) {
            boardData = JSON.parse(window.BestiaryModAPI.utility.serializeBoard());
            console.log('Target ticks: Using BestiaryModAPI.utility.serializeBoard');
          } else {
            boardData = serializeBoard();
            console.log('Target ticks: Using local serializeBoard implementation');
          }
          
          // Create a deep copy to avoid reference issues
          const boardDataCopy = structuredClone(boardData);
          boardDataCopy.seed = runSeed;
          
          targetTicksRun = {
            seed: runSeed,
            board: boardDataCopy,
            ticks: ticks,
            grade: grade,
            rankPoints: rankPoints
          };
          
          console.log(`Target ticks run captured: ${ticks} ticks with seed ${runSeed}`);
          break;
        }
        
        // Update max rank points
        if (rankPoints > maxRankPoints) {
          maxRankPoints = rankPoints;
          maxRankPointsResult = {
            ticks,
            grade,
            rankPoints,
            seed: runSeed,
            runIndex: i
          };
          
          // Store the board configuration for max points replay
          let boardData;

          if (typeof window.$serializeBoard === 'function') {
            boardData = JSON.parse(window.$serializeBoard());
            console.log('Max points: Using window.$serializeBoard directly');
          } else if (window.BestiaryModAPI && window.BestiaryModAPI.utility && window.BestiaryModAPI.utility.serializeBoard) {
            boardData = JSON.parse(window.BestiaryModAPI.utility.serializeBoard());
            console.log('Max points: Using BestiaryModAPI.utility.serializeBoard');
          } else {
            boardData = serializeBoard();
            console.log('Max points: Using local serializeBoard implementation');
          }

          // Create a deep copy to avoid reference issues
          const boardDataCopy = structuredClone(boardData);
          boardDataCopy.seed = runSeed;

          bestScoreRun = {
            seed: runSeed,
            board: boardDataCopy
          };
          
          console.log(`New max points: ${rankPoints} with seed ${runSeed} in run ${i}`);
        }
        
        // Check for force stop again
        if (forceStop) {
          console.log('Analysis stopped by user after run completed');
          break;
        }
        
        // Stop the game using direct state manipulation
        globalThis.state.board.send({
          type: "setState",
          fn: prevState => ({
            ...prevState,
            gameStarted: false
          })
        });
      } catch (runError) {
        console.error(`Error in run ${i}:`, runError);
        // Try to ensure game is stopped before continuing
        try {
          globalThis.state.board.send({
            type: "setState",
            fn: prevState => ({
              ...prevState,
              gameStarted: false
            })
          });
        } catch (e) {}
      }
      
      // Record the time taken for this run
      const runTime = performance.now() - lastRunStart;
      runTimes.push(runTime);
      console.log(`Run ${i} took ${runTime.toFixed(2)}ms`);
      
      // Brief pause between runs to ensure clean state
      await sleep(1);
    }
  } catch (error) {
    console.error('Error during analysis:', error);
    throw error;
  } finally {
    // Restore game board visibility
    if (config.hideGameBoard && gameFrame) {
      gameFrame.style.display = '';
    }
    
    // Disable turbo mode if it was enabled
    if (config.enableTurboAutomatically && turboActive) {
      disableTurbo();
    }
    
    // Ensure the game is stopped using direct state manipulation
    try {
      globalThis.state.board.send({
        type: "setState",
        fn: prevState => ({
          ...prevState,
          gameStarted: false
        })
      });
    } catch (e) {
      console.error('Error stopping game in finally block:', e);
    }
  }

  // Calculate timing statistics
  const totalTime = performance.now() - startTime;
  const averageRunTime = runTimes.length > 0 ? runTimes.reduce((sum, time) => sum + time, 0) / runTimes.length : 0;
  
  // Calculate statistics
  const sPlusRate = totalRuns > 0 ? (sPlusCount / totalRuns * 100).toFixed(2) : '0.00';
  const completionRate = totalRuns > 0 ? (completedRuns / totalRuns * 100).toFixed(2) : '0.00';
  const ticksArray = results.filter(r => r.completed).map(r => r.ticks);
  const medianTicks = calculateMedian(ticksArray);
  const averageTicks = calculateAverage(ticksArray);
  
  return {
    results,
    summary: {
      runs,
      totalRuns,
      completedRuns,
      sPlusCount,
      sPlusRate,
      completionRate,
      minTicks: isFinite(minTicks) ? minTicks : 0,
      maxTicks: Math.max(...results.map(r => r.ticks)),
      medianTicks: medianTicks,
      averageTicks: averageTicks,
      maxRankPoints,
      forceStopped: forceStop,
      modeSwitched,
      bestTimeResult: bestTimeRun,
      maxPointsResult: bestScoreRun,
      targetTicksResult: targetTicksRun,
      // Timing stats
      totalTimeMs: totalTime,
      totalTimeFormatted: formatMilliseconds(totalTime),
      averageRunTimeMs: averageRunTime,
      averageRunTimeFormatted: formatMilliseconds(averageRunTime),
      fastestRunTimeMs: Math.min(...runTimes),
      slowestRunTimeMs: Math.max(...runTimes)
    }
  };
}
```

## 4. In the `createConfigPanel` function, find where the "Stop after ticks" input ends and add:

```javascript
// Stop when ticks reached input
const stopWhenTicksContainer = document.createElement('div');
stopWhenTicksContainer.style.cssText = 'display: flex; justify-content: space-between; align-items: center;';

const stopWhenTicksLabel = document.createElement('label');
stopWhenTicksLabel.textContent = t('stopWhenTicksReachedLabel');

const stopWhenTicksInput = document.createElement('input');
stopWhenTicksInput.type = 'number';
stopWhenTicksInput.id = 'stop-when-ticks-input';
stopWhenTicksInput.min = '0';
stopWhenTicksInput.max = '10000';
stopWhenTicksInput.value = config.stopWhenTicksReached;
stopWhenTicksInput.style.cssText = 'width: 80px; text-align: center;';

stopWhenTicksContainer.appendChild(stopWhenTicksLabel);
stopWhenTicksContainer.appendChild(stopWhenTicksInput);
content.appendChild(stopWhenTicksContainer);
```

## 5. In the `updateConfig` function inside `createConfigPanel`, add this line:

```javascript
config.stopWhenTicksReached = parseInt(document.getElementById('stop-when-ticks-input').value, 10);
```

## 6. In `showResultsModal`, find where it checks for replay data and add:

```javascript
const hasTargetTicksReplay = results.summary.targetTicksResult && results.summary.targetTicksResult.board;
```

## 7. Change the buttons container condition to:

```javascript
if (hasBestTimeReplay || hasMaxPointsReplay || hasTargetTicksReplay) {
```

## 8. Add the target button after the max points button:

```javascript
// Add target ticks button if available
if (hasTargetTicksReplay) {
  const copyTargetTicksButton = document.createElement('button');
  copyTargetTicksButton.textContent = t('copyTargetTicksReplayButton');
  copyTargetTicksButton.className = 'focus-style-visible flex items-center justify-center tracking-wide text-whiteRegular disabled:cursor-not-allowed disabled:text-whiteDark/60 disabled:grayscale-50 frame-1 active:frame-pressed-1 surface-regular gap-1 px-2 py-0.5 pb-[3px] pixel-font-14';
  copyTargetTicksButton.style.cssText = 'flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
  
  // Add click handler
  copyTargetTicksButton.addEventListener('click', () => {
    // Get the board data
    const replayData = results.summary.targetTicksResult.board;
    
    // Verify and fix the replay data format
    if (!verifyAndFixReplayData(replayData)) {
      api.ui.components.createModal({
        title: 'Error',
        content: 'Failed to create replay data. The board configuration may be incomplete.',
        buttons: [{ text: 'OK', primary: true }]
      });
      return;
    }
    
    // Create the $replay formatted string
    const replayText = `$replay(${JSON.stringify(replayData)})`;
    
    // Log for debugging
    console.log('Target ticks replay text:', replayText);
    
    // Copy to clipboard
    const success = copyToClipboard(replayText);
    if (success) {
      const originalText = copyTargetTicksButton.textContent;
      copyTargetTicksButton.textContent = t('replayCopiedMessage');
      setTimeout(() => {
        copyTargetTicksButton.textContent = originalText;
      }, 2000);
    }
  });
  
  replayButtonsContainer.appendChild(copyTargetTicksButton);
}
```